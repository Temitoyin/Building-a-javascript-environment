function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var RandExp = _interopDefault(require('randexp'));
var tslib_1 = require('tslib');
var deref = _interopDefault(require('deref'));

/**
 * This class defines a registry for custom formats used within JSF.
 */
var Registry = /** @class */ (function () {
    function Registry() {
        // empty by default
        this.data = {};
    }
    /**
     * Registers custom format
     */
    Registry.prototype.register = function (name, callback) {
        this.data[name] = callback;
    };
    /**
     * Register many formats at one shot
     */
    Registry.prototype.registerMany = function (formats) {
        for (var name in formats) {
            this.data[name] = formats[name];
        }
    };
    /**
     * Returns element by registry key
     */
    Registry.prototype.get = function (name) {
        var format = this.data[name];
        if (typeof format === 'undefined') {
            throw new Error('unknown registry key ' + JSON.stringify(name));
        }
        return format;
    };
    /**
     * Returns the whole registry content
     */
    Registry.prototype.list = function () {
        return this.data;
    };
    return Registry;
}());

/**
 * This class defines a registry for custom formats used within JSF.
 */
var OptionRegistry = /** @class */ (function (_super) {
    tslib_1.__extends(OptionRegistry, _super);
    function OptionRegistry() {
        var _this = _super.call(this) || this;
        _this.data['failOnInvalidTypes'] = true;
        _this.data['defaultInvalidTypeProduct'] = null;
        _this.data['useDefaultValue'] = false;
        _this.data['requiredOnly'] = false;
        _this.data['maxItems'] = null;
        _this.data['maxLength'] = null;
        _this.data['defaultMinItems'] = 0;
        _this.data['defaultRandExpMax'] = 10;
        _this.data['alwaysFakeOptionals'] = false;
        _this.data['random'] = Math.random;
        return _this;
    }
    return OptionRegistry;
}(Registry));

// instantiate
var registry = new OptionRegistry();
/**
 * Custom option API
 *
 * @param nameOrOptionMap
 * @returns {any}
 */
function optionAPI(nameOrOptionMap) {
    if (typeof nameOrOptionMap === 'string') {
        return registry.get(nameOrOptionMap);
    }
    else {
        return registry.registerMany(nameOrOptionMap);
    }
}

// set maximum default, see #193
RandExp.prototype.max = 10;
// same implementation as the original except using our random
RandExp.prototype.randInt = function (a, b) {
    return a + Math.floor(optionAPI('random')() * (1 + b - a));
};
/**
 * Container is used to wrap external libraries (faker, chance, casual, randexp) that are used among the whole codebase. These
 * libraries might be configured, customized, etc. and each internal JSF module needs to access those instances instead
 * of pure npm module instances. This class supports consistent access to these instances.
 */
var Container = /** @class */ (function () {
    function Container() {
        // static requires - handle both initial dependency load (deps will be available
        // among other modules) as well as they will be included by browserify AST
        this.registry = {
            faker: null,
            chance: null,
            casual: null,
            // randexp is required for "pattern" values
            randexp: RandExp
        };
    }
    /**
     * Override dependency given by name
     * @param name
     * @param callback
     */
    Container.prototype.extend = function (name, callback) {
        if (typeof this.registry[name] === 'undefined') {
            throw new ReferenceError('"' + name + '" dependency is not allowed.');
        }
        this.registry[name] = callback(this.registry[name]);
    };
    /**
     * Returns dependency given by name
     * @param name
     * @returns {Dependency}
     */
    Container.prototype.get = function (name) {
        if (typeof this.registry[name] === 'undefined') {
            throw new ReferenceError('"' + name + '" dependency doesn\'t exist.');
        }
        else if (name === 'randexp') {
            var RandExp_ = this.registry['randexp'];
            // wrapped generator
            return function (pattern) {
                var re = new RandExp_(pattern);
                // apply given setting
                re.max = optionAPI('defaultRandExpMax');
                return re.gen();
            };
        }
        return this.registry[name];
    };
    /**
     * Returns all dependencies
     *
     * @returns {Registry}
     */
    Container.prototype.getAll = function () {
        return {
            faker: this.get('faker'),
            chance: this.get('chance'),
            randexp: this.get('randexp'),
            casual: this.get('casual')
        };
    };
    return Container;
}());
// TODO move instantiation somewhere else (out from class file)
// instantiate
var container = new Container();

// instantiate
var registry$1 = new Registry();
/**
 * Custom format API
 *
 * @see https://github.com/json-schema-faker/json-schema-faker#custom-formats
 * @param nameOrFormatMap
 * @param callback
 * @returns {any}
 */
function formatAPI(nameOrFormatMap, callback) {
    if (typeof nameOrFormatMap === 'undefined') {
        return registry$1.list();
    }
    else if (typeof nameOrFormatMap === 'string') {
        if (typeof callback === 'function') {
            registry$1.register(nameOrFormatMap, callback);
        }
        else {
            return registry$1.get(nameOrFormatMap);
        }
    }
    else {
        registry$1.registerMany(nameOrFormatMap);
    }
}

/// <reference path="../index.d.ts" />
/**
 * Returns random element of a collection
 *
 * @param collection
 * @returns {T}
 */
function pick(collection) {
    return collection[Math.floor(optionAPI('random')() * collection.length)];
}
/**
 * Returns shuffled collection of elements
 *
 * @param collection
 * @returns {T[]}
 */
function shuffle(collection) {
    var tmp, key, copy = collection.slice(), length = collection.length;
    for (; length > 0;) {
        key = Math.floor(optionAPI('random')() * length);
        // swap
        tmp = copy[--length];
        copy[length] = copy[key];
        copy[key] = tmp;
    }
    return copy;
}
/**
 * These values determine default range for random.number function
 *
 * @type {number}
 */
var MIN_NUMBER = -100;
var MAX_NUMBER = 100;
/**
 * Returns a random integer between min (inclusive) and max (inclusive)
 * Using Math.round() will give you a non-uniform distribution!
 * @see http://stackoverflow.com/a/1527820/769384
 */
function getRandomInt(min, max) {
    return Math.floor(optionAPI('random')() * (max - min + 1)) + min;
}
/**
 * Generates random number according to parameters passed
 *
 * @param min
 * @param max
 * @param defMin
 * @param defMax
 * @param hasPrecision
 * @returns {number}
 */
function number(min, max, defMin, defMax, hasPrecision) {
    if (hasPrecision === void 0) { hasPrecision = false; }
    defMin = typeof defMin === 'undefined' ? MIN_NUMBER : defMin;
    defMax = typeof defMax === 'undefined' ? MAX_NUMBER : defMax;
    min = typeof min === 'undefined' ? defMin : min;
    max = typeof max === 'undefined' ? defMax : max;
    if (max < min) {
        max += min;
    }
    var result = getRandomInt(min, max);
    if (!hasPrecision) {
        return parseInt(result + '', 10);
    }
    return result;
}
var random = {
    pick: pick,
    shuffle: shuffle,
    number: number,
};

var ParseError = /** @class */ (function (_super) {
    tslib_1.__extends(ParseError, _super);
    function ParseError(message, path) {
        var _this = _super.call(this) || this;
        _this.path = path;
        Error.captureStackTrace(_this, _this.constructor);
        _this.name = 'ParseError';
        _this.message = message;
        _this.path = path;
        return _this;
    }
    return ParseError;
}(Error));

var inferredProperties = {
    array: [
        'additionalItems',
        'items',
        'maxItems',
        'minItems',
        'uniqueItems'
    ],
    integer: [
        'exclusiveMaximum',
        'exclusiveMinimum',
        'maximum',
        'minimum',
        'multipleOf'
    ],
    object: [
        'additionalProperties',
        'dependencies',
        'maxProperties',
        'minProperties',
        'patternProperties',
        'properties',
        'required'
    ],
    string: [
        'maxLength',
        'minLength',
        'pattern'
    ]
};
inferredProperties.number = inferredProperties.integer;
var subschemaProperties = [
    'additionalItems',
    'items',
    'additionalProperties',
    'dependencies',
    'patternProperties',
    'properties'
];
/**
 * Iterates through all keys of `obj` and:
 * - checks whether those keys match properties of a given inferred type
 * - makes sure that `obj` is not a subschema; _Do not attempt to infer properties named as subschema containers. The
 * reason for this is that any property name within those containers that matches one of the properties used for
 * inferring missing type values causes the container itself to get processed which leads to invalid output. (Issue 62)_
 *
 * @returns {boolean}
 */
function matchesType(obj, lastElementInPath, inferredTypeProperties) {
    return Object.keys(obj).filter(function (prop) {
        var isSubschema = subschemaProperties.indexOf(lastElementInPath) > -1, inferredPropertyFound = inferredTypeProperties.indexOf(prop) > -1;
        if (inferredPropertyFound && !isSubschema) {
            return true;
        }
    }).length > 0;
}
/**
 * Checks whether given `obj` type might be inferred. The mechanism iterates through all inferred types definitions,
 * tries to match allowed properties with properties of given `obj`. Returns type name, if inferred, or null.
 *
 * @returns {string|null}
 */
function inferType(obj, schemaPath) {
    for (var typeName in inferredProperties) {
        var lastElementInPath = schemaPath[schemaPath.length - 1];
        if (matchesType(obj, lastElementInPath, inferredProperties[typeName])) {
            return typeName;
        }
    }
}

/**
 * Generates randomized boolean value.
 *
 * @returns {boolean}
 */
function booleanGenerator() {
    return optionAPI('random')() > 0.5;
}

var booleanType = booleanGenerator;

/**
 * Generates null value.
 *
 * @returns {null}
 */
function nullGenerator() {
    return null;
}

var nullType = nullGenerator;

function getSubAttribute(obj, dotSeparatedKey) {
    var keyElements = dotSeparatedKey.split('.');
    while (keyElements.length) {
        var prop = keyElements.shift();
        if (!obj[prop]) {
            break;
        }
        obj = obj[prop];
    }
    return obj;
}
/**
 * Returns true/false whether the object parameter has its own properties defined
 *
 * @param obj
 * @param properties
 * @returns {boolean}
 */
function hasProperties(obj) {
    var properties = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        properties[_i - 1] = arguments[_i];
    }
    return properties.filter(function (key) {
        return typeof obj[key] !== 'undefined';
    }).length > 0;
}
/**
 * Returns typecasted value.
 * External generators (faker, chance, casual) may return data in non-expected formats, such as string, when you might expect an
 * integer. This function is used to force the typecast.
 *
 * @param value
 * @param targetType
 * @returns {any}
 */
function typecast(value, targetType) {
    switch (targetType) {
        case 'integer':
            return parseInt(value, 10);
        case 'number':
            return parseFloat(value);
        case 'string':
            return '' + value;
        case 'boolean':
            return !!value;
        default:
            return value;
    }
}
function clone(arr) {
    var out = [];
    arr.forEach(function (item, index) {
        if (typeof item === 'object' && item !== null) {
            out[index] = Array.isArray(item) ? clone(item) : merge({}, item);
        }
        else {
            out[index] = item;
        }
    });
    return out;
}
// TODO refactor merge function
function merge(a, b) {
    for (var key in b) {
        if (typeof b[key] !== 'object' || b[key] === null) {
            a[key] = b[key];
        }
        else if (Array.isArray(b[key])) {
            a[key] = (a[key] || []).concat(clone(b[key]));
        }
        else if (typeof a[key] !== 'object' || a[key] === null || Array.isArray(a[key])) {
            a[key] = merge({}, b[key]);
        }
        else {
            a[key] = merge(a[key], b[key]);
        }
    }
    return a;
}
var utils = {
    getSubAttribute: getSubAttribute,
    hasProperties: hasProperties,
    typecast: typecast,
    clone: clone,
    merge: merge
};

// TODO provide types
function unique(path, items, value, sample, resolve, traverseCallback) {
    var tmp = [], seen = [];
    function walk(obj) {
        var json = JSON.stringify(obj);
        if (seen.indexOf(json) === -1) {
            seen.push(json);
            tmp.push(obj);
        }
    }
    items.forEach(walk);
    // TODO: find a better solution?
    var limit = 100;
    while (tmp.length !== items.length) {
        walk(traverseCallback(value.items || sample, path, resolve));
        if (!limit--) {
            break;
        }
    }
    return tmp;
}
// TODO provide types
var arrayType = function arrayType(value, path, resolve, traverseCallback) {
    var items = [];
    if (!(value.items || value.additionalItems)) {
        if (utils.hasProperties(value, 'minItems', 'maxItems', 'uniqueItems')) {
            throw new ParseError('missing items for ' + JSON.stringify(value), path);
        }
        return items;
    }
    // see http://stackoverflow.com/a/38355228/769384
    // after type guards support subproperties (in TS 2.0) we can simplify below to (value.items instanceof Array)
    // so that value.items.map becomes recognized for typescript compiler
    var tmpItems = value.items;
    if (tmpItems instanceof Array) {
        return Array.prototype.concat.apply(items, tmpItems.map(function (item, key) {
            var itemSubpath = path.concat(['items', key + '']);
            return traverseCallback(item, itemSubpath, resolve);
        }));
    }
    var minItems = value.minItems;
    var maxItems = value.maxItems;
    if (optionAPI('defaultMinItems') && minItems === undefined) {
        // fix boundaries
        minItems = !maxItems
            ? optionAPI('defaultMinItems')
            : Math.min(optionAPI('defaultMinItems'), maxItems);
    }
    if (optionAPI('maxItems')) {
        // Don't allow user to set max items above our maximum
        if (maxItems && maxItems > optionAPI('maxItems')) {
            maxItems = optionAPI('maxItems');
        }
        // Don't allow user to set min items above our maximum
        if (minItems && minItems > optionAPI('maxItems')) {
            minItems = maxItems;
        }
    }
    var length = random.number(minItems, maxItems, 1, 5), 
    // TODO below looks bad. Should additionalItems be copied as-is?
    sample = typeof value.additionalItems === 'object' ? value.additionalItems : {};
    for (var current = items.length; current < length; current++) {
        var itemSubpath = path.concat(['items', current + '']);
        var element = traverseCallback(value.items || sample, itemSubpath, resolve);
        items.push(element);
    }
    if (value.uniqueItems) {
        return unique(path.concat(['items']), items, value, sample, resolve, traverseCallback);
    }
    return items;
};

var MIN_INTEGER = -100000000;
var MAX_INTEGER = 100000000;
var numberType = function numberType(value) {
    var min = typeof value.minimum === 'undefined' ? MIN_INTEGER : value.minimum, max = typeof value.maximum === 'undefined' ? MAX_INTEGER : value.maximum, multipleOf = value.multipleOf;
    if (multipleOf) {
        max = Math.floor(max / multipleOf) * multipleOf;
        min = Math.ceil(min / multipleOf) * multipleOf;
    }
    if (value.exclusiveMinimum && value.minimum && min === value.minimum) {
        min += multipleOf || 1;
    }
    if (value.exclusiveMaximum && value.maximum && max === value.maximum) {
        max -= multipleOf || 1;
    }
    if (min > max) {
        return NaN;
    }
    if (multipleOf) {
        return Math.floor(random.number(min, max) / multipleOf) * multipleOf;
    }
    return random.number(min, max, undefined, undefined, true);
};

// The `integer` type is just a wrapper for the `number` type. The `number` type
// returns floating point numbers, and `integer` type truncates the fraction
// part, leaving the result as an integer.
var integerType = function integerType(value) {
    var generated = numberType(value);
    // whether the generated number is positive or negative, need to use either
    // floor (positive) or ceil (negative) function to get rid of the fraction
    return generated > 0 ? Math.floor(generated) : Math.ceil(generated);
};

var LIPSUM_WORDS = ('Lorem ipsum dolor sit amet consectetur adipisicing elit sed do eiusmod tempor incididunt ut labore'
    + ' et dolore magna aliqua Ut enim ad minim veniam quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea'
    + ' commodo consequat Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla'
    + ' pariatur Excepteur sint occaecat cupidatat non proident sunt in culpa qui officia deserunt mollit anim id est'
    + ' laborum').split(' ');
/**
 * Generates randomized array of single lorem ipsum words.
 *
 * @param length
 * @returns {Array.<string>}
 */
function wordsGenerator(length) {
    var words = random.shuffle(LIPSUM_WORDS);
    return words.slice(0, length);
}

// TODO: tsify
function isArray(obj) {
    return obj && Array.isArray(obj);
}
function isObject(obj) {
    return obj && obj !== null && typeof obj === 'object';
}
function hasNothing(obj) {
    if (isArray(obj)) {
        return obj.length === 0;
    }
    if (isObject(obj)) {
        return Object.keys(obj).length === 0;
    }
    return typeof obj === 'undefined' || obj === null;
}
function removeProps(obj, key, parent, required) {
    var i, value, isFullyEmpty = true;
    if (isArray(obj)) {
        for (i = 0; i < obj.length; ++i) {
            value = obj[i];
            if (isObject(value)) {
                removeProps(value, i, obj);
            }
            if (hasNothing(value)) {
                obj.splice(i--, 1);
            }
            else {
                isFullyEmpty = false;
            }
        }
    }
    else {
        for (i in obj) {
            value = obj[i];
            if (required && required.indexOf(i) > -1) {
                isFullyEmpty = false;
                removeProps(value);
                continue;
            }
            if (isObject(value)) {
                removeProps(value, i, obj);
            }
            if (hasNothing(value)) {
                delete obj[i];
            }
            else {
                isFullyEmpty = false;
            }
        }
    }
    if (typeof key !== 'undefined' && isFullyEmpty) {
        delete parent[key];
        removeProps(obj);
    }
}
function clean (obj, required) {
    removeProps(obj, undefined, undefined, required);
    return obj;
}

var randexp = container.get('randexp');
// fallback generator
var anyType = { type: ['string', 'number', 'integer', 'boolean'] };
// TODO provide types
var objectType = function objectType(value, path, resolve, traverseCallback) {
    var props = {};
    var properties = value.properties || {};
    var patternProperties = value.patternProperties || {};
    var requiredProperties = (value.required || []).slice();
    var allowsAdditional = value.additionalProperties === false ? false : true;
    var propertyKeys = Object.keys(properties);
    var patternPropertyKeys = Object.keys(patternProperties);
    var additionalProperties = allowsAdditional
        ? (value.additionalProperties === true ? {} : value.additionalProperties)
        : null;
    if (!allowsAdditional &&
        propertyKeys.length === 0 &&
        patternPropertyKeys.length === 0 &&
        utils.hasProperties(value, 'minProperties', 'maxProperties', 'dependencies', 'required')) {
        throw new ParseError('missing properties for:\n' + JSON.stringify(value, null, '  '), path);
    }
    if (optionAPI('requiredOnly') === true) {
        requiredProperties.forEach(function (key) {
            if (properties[key]) {
                props[key] = properties[key];
            }
        });
        return clean(traverseCallback(props, path.concat(['properties']), resolve), value.required);
    }
    var min = Math.max(value.minProperties || 0, requiredProperties.length);
    var max = Math.max(value.maxProperties || random.number(min, min + 5));
    random.shuffle(patternPropertyKeys.concat(propertyKeys)).forEach(function (_key) {
        if (requiredProperties.indexOf(_key) === -1) {
            requiredProperties.push(_key);
        }
    });
    // properties are read from right-to-left
    var _props = optionAPI('alwaysFakeOptionals') ? requiredProperties
        : requiredProperties.slice(0, random.number(min, max));
    _props.forEach(function (key) {
        // first ones are the required properies
        if (properties[key]) {
            props[key] = properties[key];
        }
        else {
            var found;
            // then try patternProperties
            patternPropertyKeys.forEach(function (_key) {
                if (key.match(new RegExp(_key))) {
                    found = true;
                    props[randexp(key)] = patternProperties[_key];
                }
            });
            if (!found) {
                // try patternProperties again,
                var subschema = patternProperties[key] || additionalProperties;
                if (subschema) {
                    // otherwise we can use additionalProperties?
                    props[patternProperties[key] ? randexp(key) : key] = subschema;
                }
            }
        }
    });
    var current = Object.keys(props).length;
    while (true) {
        if (!(patternPropertyKeys.length || allowsAdditional)) {
            break;
        }
        if (current >= min) {
            break;
        }
        if (allowsAdditional) {
            var word = wordsGenerator(1) + randexp('[a-f\\d]{1,3}');
            if (!props[word]) {
                props[word] = additionalProperties || anyType;
                current += 1;
            }
        }
        patternPropertyKeys.forEach(function (_key) {
            var word = randexp(_key);
            if (!props[word]) {
                props[word] = patternProperties[_key];
                current += 1;
            }
        });
    }
    if (!allowsAdditional && current < min) {
        throw new ParseError('properties constraints were too strong to successfully generate a valid object for:\n' +
            JSON.stringify(value, null, '  '), path);
    }
    return clean(traverseCallback(props, path.concat(['properties']), resolve), value.required);
};

/**
 * Helper function used by thunkGenerator to produce some words for the final result.
 *
 * @returns {string}
 */
function produce() {
    var length = random.number(1, 5);
    return wordsGenerator(length).join(' ');
}
/**
 * Generates randomized concatenated string based on words generator.
 *
 * @returns {string}
 */
function thunkGenerator(min, max) {
    if (min === void 0) { min = 0; }
    if (max === void 0) { max = 140; }
    var min = Math.max(0, min), max = random.number(min, max), result = produce();
    // append until length is reached
    while (result.length < min) {
        result += produce();
    }
    // cut if needed
    if (result.length > max) {
        result = result.substr(0, max);
    }
    return result;
}

/**
 * Generates randomized ipv4 address.
 *
 * @returns {string}
 */
function ipv4Generator() {
    return [0, 0, 0, 0].map(function () {
        return random.number(0, 255);
    }).join('.');
}

/**
 * Generates randomized date time ISO format string.
 *
 * @returns {string}
 */
function dateTimeGenerator() {
    return new Date(random.number(0, 100000000000000)).toISOString();
}

var randexp$2 = container.get('randexp');
/**
 * Predefined core formats
 * @type {[key: string]: string}
 */
var regexps = {
    email: '[a-zA-Z\\d][a-zA-Z\\d-]{1,13}[a-zA-Z\\d]@{hostname}',
    hostname: '[a-zA-Z]{1,33}\\.[a-z]{2,4}',
    ipv6: '[a-f\\d]{4}(:[a-f\\d]{4}){7}',
    uri: '[a-zA-Z][a-zA-Z0-9+-.]*'
};
/**
 * Generates randomized string basing on a built-in regex format
 *
 * @param coreFormat
 * @returns {string}
 */
function coreFormatGenerator(coreFormat) {
    return randexp$2(regexps[coreFormat]).replace(/\{(\w+)\}/, function (match, key) {
        return randexp$2(regexps[key]);
    });
}

var randexp$1 = container.get('randexp');
function generateFormat(value) {
    switch (value.format) {
        case 'date-time':
            return dateTimeGenerator();
        case 'ipv4':
            return ipv4Generator();
        case 'regex':
            // TODO: discuss
            return '.+?';
        case 'email':
        case 'hostname':
        case 'ipv6':
        case 'uri':
            return coreFormatGenerator(value.format);
        default:
            var callback = formatAPI(value.format);
            return callback(container.getAll(), value);
    }
}
var stringType = function stringType(value) {
    var output;
    var minLength = value.minLength;
    var maxLength = value.maxLength;
    if (optionAPI('maxLength')) {
        // Don't allow user to set max length above our maximum
        if (maxLength && maxLength > optionAPI('maxLength')) {
            maxLength = optionAPI('maxLength');
        }
        // Don't allow user to set min length above our maximum
        if (minLength && minLength > optionAPI('maxLength')) {
            minLength = optionAPI('maxLength');
        }
    }
    if (value.format) {
        output = generateFormat(value);
    }
    else if (value.pattern) {
        output = randexp$1(value.pattern);
    }
    else {
        output = thunkGenerator(minLength, maxLength);
    }
    while (output.length < minLength) {
        output += optionAPI('random')() > 0.7 ? thunkGenerator() : randexp$1('.+');
    }
    if (output.length > maxLength) {
        output = output.substr(0, maxLength);
    }
    return output;
};

var externalType = function externalType(value, path) {
    var libraryName = value.faker ? 'faker' : (value.chance ? 'chance' : 'casual'), libraryModule = container.get(libraryName), key = value.faker || value.chance || value.casual, path = key, args = [];
    if (typeof path === 'object') {
        path = Object.keys(path)[0];
        if (Array.isArray(key[path])) {
            args = key[path];
        }
        else {
            args.push(key[path]);
        }
    }
    var genFunction = utils.getSubAttribute(libraryModule, path);
    try {
        // see #116, #117 - faker.js 3.1.0 introduced local dependencies between generators
        // making jsf break after upgrading from 3.0.1
        var contextObject = libraryModule;
        if (libraryName === 'faker') {
            var parts = path.split('.');
            while (parts.length > 1) {
                contextObject = libraryModule[parts.shift()];
            }
            genFunction = contextObject[parts[0]];
        }
    }
    catch (e) {
        throw new Error('cannot resolve ' + libraryName + '-generator for ' + JSON.stringify(key));
    }
    if (typeof genFunction !== 'function') {
        if (libraryName === 'casual') {
            return utils.typecast(genFunction, value.type);
        }
        throw new Error('unknown ' + libraryName + '-generator for ' + JSON.stringify(key));
    }
    var result = genFunction.apply(contextObject, args);
    return utils.typecast(result, value.type);
};

var typeMap = {
    boolean: booleanType,
    null: nullType,
    array: arrayType,
    integer: integerType,
    number: numberType,
    object: objectType,
    string: stringType,
    external: externalType
};

function isExternal(schema) {
    return schema.faker || schema.chance || schema.casual;
}
function reduceExternal(schema, path) {
    if (schema['x-faker']) {
        schema.faker = schema['x-faker'];
    }
    if (schema['x-chance']) {
        schema.chance = schema['x-chance'];
    }
    if (schema['x-casual']) {
        schema.casual = schema['x-casual'];
    }
    var count = (schema.faker !== undefined ? 1 : 0) +
        (schema.chance !== undefined ? 1 : 0) +
        (schema.casual !== undefined ? 1 : 0);
    if (count > 1) {
        throw new ParseError('ambiguous generator mixing faker, chance or casual: ' + JSON.stringify(schema), path);
    }
    return schema;
}
// TODO provide types
function traverse(schema, path, resolve) {
    resolve(schema);
    if (Array.isArray(schema.enum)) {
        return random.pick(schema.enum);
    }
    if (optionAPI('useDefaultValue') && 'default' in schema) {
        return schema.default;
    }
    // TODO remove the ugly overcome
    var type = schema.type;
    if (Array.isArray(type)) {
        type = random.pick(type);
    }
    else if (typeof type === 'undefined') {
        // Attempt to infer the type
        type = inferType(schema, path) || type;
    }
    schema = reduceExternal(schema, path);
    if (isExternal(schema)) {
        type = 'external';
    }
    if (typeof type === 'string') {
        if (!typeMap[type]) {
            if (optionAPI('failOnInvalidTypes')) {
                throw new ParseError('unknown primitive ' + JSON.stringify(type), path.concat(['type']));
            }
            else {
                return optionAPI('defaultInvalidTypeProduct');
            }
        }
        else {
            try {
                return typeMap[type](schema, path, resolve, traverse);
            }
            catch (e) {
                if (typeof e.path === 'undefined') {
                    throw new ParseError(e.message, path);
                }
                throw e;
            }
        }
    }
    var copy = {};
    if (Array.isArray(schema)) {
        copy = [];
    }
    for (var prop in schema) {
        if (typeof schema[prop] === 'object' && prop !== 'definitions') {
            copy[prop] = traverse(schema[prop], path.concat([prop]), resolve);
        }
        else {
            copy[prop] = schema[prop];
        }
    }
    return copy;
}

function isKey(prop) {
    return prop === 'enum' || prop === 'default' || prop === 'required' || prop === 'definitions';
}
// TODO provide types
function run(schema, refs, ex) {
    var $ = deref();
    var _ = {};
    try {
        return traverse($(schema, refs, ex), [], function reduce(sub, maxReduceDepth) {
            if (typeof maxReduceDepth === 'undefined') {
                maxReduceDepth = random.number(1, 3);
            }
            if (!sub) {
                return null;
            }
            if (typeof sub.$ref === 'string') {
                var id = sub.$ref;
                // match and increment seen references
                if (!_[id]) {
                    _[id] = 0;
                }
                _[id] += 1;
                // cleanup
                delete sub.$ref;
                if (_[id] > maxReduceDepth) {
                    delete sub.oneOf;
                    delete sub.anyOf;
                    delete sub.allOf;
                    return sub;
                }
                utils.merge(sub, $.util.findByRef(id, $.refs));
            }
            if (Array.isArray(sub.allOf)) {
                var schemas = sub.allOf;
                delete sub.allOf;
                // this is the only case where all sub-schemas
                // must be resolved before any merge
                schemas.forEach(function (schema) {
                    utils.merge(sub, reduce(schema, maxReduceDepth + 1));
                });
            }
            if (Array.isArray(sub.oneOf || sub.anyOf)) {
                var mix = sub.oneOf || sub.anyOf;
                delete sub.anyOf;
                delete sub.oneOf;
                utils.merge(sub, random.pick(mix));
            }
            for (var prop in sub) {
                if ((Array.isArray(sub[prop]) || typeof sub[prop] === 'object') && !isKey(prop)) {
                    sub[prop] = reduce(sub[prop], maxReduceDepth);
                }
            }
            return sub;
        });
    }
    catch (e) {
        if (e.path) {
            throw new Error(e.message + ' in ' + '/' + e.path.join('/'));
        }
        else {
            throw e;
        }
    }
}

var jsf = function (schema, refs) {
    return run(schema, refs);
};
jsf.format = formatAPI;
jsf.option = optionAPI;
// returns itself for chaining
jsf.extend = function (name, cb) {
    container.extend(name, cb);
    return jsf;
};
var VERSION="0.4.7";
jsf.version = VERSION;

module.exports = jsf;
